#!/usr/bin/env python
import urllib2
import urllib
import socket
import getopt
import sys
import os

SOCKET_TIMEOUT=10
#BASE_URL="http://history.shellsink.com"
BASE_URL="http://localhost:8080"
SEND_URL=BASE_URL + "/history/add"
PULL_URL=BASE_URL + "/pull"

class Client:
  def __init__(self):
    verify_environment()
    self.history_file = os.environ['HOME'] + "/.bash_history"
    self.history_timestamp = os.environ['HOME'] + "/.bash_history_timestamp"
    self.config = os.environ['HOME'] + "/.shellsink"
    self.config_file = os.environ['HOME'] + "/.shellsink/config"
    self.disable_slug = os.environ['HOME'] + "/.shellsink/disable_slug"
    self.id = os.environ['SHELL_SINK_ID']
    self.tags = os.environ['SHELL_SINK_TAGS']

  def url_with_send_command(self):
    params = {'hash' : self.id, 'command' : self.latest_from_history(), 'tags' : self.tags}
    data = urllib.urlencode(params)
    return SEND_URL + '?' + data

  def url_with_pull_command(self):
    params = {'hash': self.id}
    if self.tag:
      params['tag'] = self.tag
    if self.keyword:
      params['keyword'] = self.keyword
    data = urllib.urlencode(params)
    return PULL_URL + '?' + data

  def send_command(self):
    if self.has_new_command():
      self.spawn_process(http_get, self.url_with_send_command())
  
  def get_history(self):
    response = http_get(self.url_with_pull_command())
    commands = response.read()
    if commands.find('<shellsink-commands>') < 0:
      print "Is your SHELL_SINK_ID env variable correct?"
      exit(1)
    commands = commands.split('<shellsink-commands>')
    if len(commands) < 2:
      print "No commands matched your query."
      exit(0)
    commands = commands[1]
    return commands.split('</shellsink-commands>')[0].lstrip().rstrip()

  def spawn_process(self, func, arg):
    pid = os.fork()
    if pid > 0:
      sys.exit(0)
    os.setsid()
    pid = os.fork()
    if pid > 0:
      sys.exit(0)
    func(arg)

  def has_new_command(self):
    new_history_timestamp = self.history_file_timestamp()
    timestamp_if_there_is_no_last_recorded = new_history_timestamp - 1
    last_recorded_history_timestamp = self.last_recorded_history_timestamp()
    if not last_recorded_history_timestamp:
      last_recorded_history_timestamp = timestamp_if_there_is_no_last_recorded

    self.record_new_last_recorded_history_timestamp(new_history_timestamp)
    return new_history_timestamp > last_recorded_history_timestamp

  def history_file_timestamp(self):
    return os.path.getmtime(self.history_file)

  def last_recorded_history_timestamp(self):
    if os.path.exists(self.history_timestamp):
      file = open(self.history_timestamp,"r")
      old_history_timestamp = float(file.readline())
      file.close()
      return old_history_timestamp
    return None

  def record_new_last_recorded_history_timestamp(self, timestamp):
    file = open(self.history_timestamp,"w")
    file.writelines([str(timestamp)])
    file.close()

  def latest_from_history(self):
    file = open(self.history_file, "r")
    latest = file.readlines()[-1]
    file.close()
    return latest

  def enable(self):
    if os.path.exists(self.disable_slug):
      os.remove(self.disable_slug) 
    
  def disable(self):
    file = open(self.disable_slug, "w")
    file.close()

  def is_enabled(self):
    return not os.path.exists(self.disable_slug)

  def conf(self):
    base = ["""#shellsink-client, a client for remote archiving your shell history"""]
    if not os.path.exists(self.config):
      os.mkdir(self.config)
    if not os.path.exists(self.config_file):
      file = open(self.config_file,"w")
      file.writelines(base)
      file.close()
    file = open(self.config_file, "r")
    self.config = file.readlines()
    file.close()

  def pull(self):
    history_content = self.get_history()
    file = open(self.history_file, "a")
    file.writelines(history_content)
    file.close()

def http_get(url):
  try:
    return urllib2.urlopen(url)
  except:
    pass

def get_tag(opts):
  for opt in opts:
    if opt[0] in ["-t", "--tag"]:
      return opt[1]
  return None

def get_keyword(opts):
  for opt in opts:
    if opt[0] in ["-k", "--keyword"]:
      return opt[1]
  return None

def verify_environment():
  if not os.environ.has_key('HOME'):
    raise Exception, "HOME environment variable must be set"
  if not os.environ.has_key('SHELL_SINK_ID'):
    raise Exception, "SHELL_SINK_ID environment variable must be set"
  if not os.environ.has_key('SHELL_SINK_TAGS'):
    raise Exception, "SHELL_SINK_TAGS can be empty but must exist"

def usage():
  print """usage: shellsink-client [ -h|-e|-d|-p [ -t TAG|-k KEYWORD ] ] | [ --help|--enable|--disable|--pull [ --tag TAG|--keyword KEYWORD ] ]
  When using the pull option empty quotes will pull the most recent commands into your shell history,
  specifying a TAG string will pull the most recent commands """

def main():
  try:
    opts, args = getopt.getopt(sys.argv[1:], "hedpt:k:", ["help", "enable", "disable", "pull", "tag=", "keyword="])
  except getopt.GetoptError, err:
    # print help information and exit:
    print str(err) # will print something like "option -a not recognized"
    usage()
    sys.exit(2)

  client = Client()
  client.conf()
  for o, a in opts:
    if o in ("-h", "--help"):
      usage()
      sys.exit()
    elif o in ("-e", "--enable"):
      client.enable()
      sys.exit(0)
    elif o in ("-d", "--disable"):
      client.disable()
      sys.exit(0)
    elif o in ("-p", "--pull"):
      client.tag = get_tag(opts)
      client.keyword = get_keyword(opts)
      client.pull()
      print "History file updated.  Execute 'history -r' to add the commands to your current bash session."
      sys.exit(0)
    else:
      assert False, "unhandled option"

  socket.setdefaulttimeout(SOCKET_TIMEOUT)
  if client.is_enabled():
    client.send_command()

if __name__== '__main__':
  main()


